
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%  PARSING REGULAR TEXT
%  - take care about line ends, paragraphs and special 
%    marks as §1: §2: §R1: §R2:
%
% inputsong - process given song file
%
{\catcode`\N=13%
\gdef\inputsong#1{%
  \bgroup\catcode`\N=13% we ar looking for first N:
  \def N{\egroup\bgroup\catcode`\^^M=13\getheader}%
  \input#1
  \endsong%
}}  
% getheader - reads 5 header fields, call formating macro, 
%             starts environment for text of the song  
%
{\catcode`\^^M=13%
\gdef\getheader#1^^M#2^^M#3^^M#4^^M#5^^M{%
%\gdef\getheader #1X#2X#3X#4X#5X{%
   \egroup% 
   \MakeSongHeader{#1}{#2}{#3}{#4}{#5}%
   \beginsong%
}}
%  beginsong - setup environment
%  
{\catcode`\(=13\catcode`\^^M=13%
\gdef\beginsong{%
  \begingroup%
  \catcode`\^^M=13\def^^M{\doEOL}% 
  \let\EOLtok=^^M% to have exactly same token for testing
  \catcode`\(=13\def({\beginchord}%
  %\catcode\songESC=0% 
  \skipEOL\relax% skip all ^^M and begin new paragraph
}}%
\def\endsong{\egroup\endgroup}
%
% firstEOL, secondEOL - one ^^M = end of line, two and more = "\par"
% 
\def\doEOL{\futurelet\nextEOL\firstEOL}%
\long\def\firstEOL{%
  \hfil\egroup% close text environment
  \ifx\nextEOL\EOLtok % end par
     \par\let\next=\skipEOL% skip EOLs and begin new one
  \else% end of line inside a paragraph
    \hfill\break% hard line break
    \hskip\parindent\let\next\begintext% start new line
  \fi\next}
%%%% 
\def\skipEOL#1{\futurelet\nextEOL\skipEOLA}%
\def\skipEOLA{%
  \ifx\nextEOL\EOLtok \let\next=\skipEOL%
  \else \let\next=\newpar%
  \fi\next}
\def\newpar{
  \bgroup\aftergroup\begintext\checkmarks
}
%%%%
% checkmarks - hack for 1:, R:, or R1: ...
%   we will set \versetype=(V|R|0)
%   and define \versenum for number tokens
%   this can be used in definition of \everypar
%   which come after
\def\checkmarks{\futurelet\nextChar\firstcheck}%
\def\firstcheck{%
  \ifx\nextChar R\let\next=\getref%
  \else\let\afternumber=\setverse\let\next=\getnum\fi%
  \next}%  
\def\getref R{\let\afternumber=\setref\getnum}%
%%%%%
% reads number ended by colon then call \afternumber
% with tokens been read  
\newtoks\savenum
\def\getnum{\bgroup\futurelet\nextChar\getnumA}
%
\def\ifdigit#1#2{\ifnum`#1>47 \ifnum`#1<58 #2\fi}
\def\ignoreChar#1{}%
%
\def\getnumA{%
   \let\next=\getnumWrong
   \ifdigit\nextChar{\let\next=\getnumNext}%
   \ifx:\nextChar \let\next=\getnumOK%
   \next}   
\def\getnumNext#1{% get next digit
  \expandafter\savenum\expandafter{\the\savenum #1}%
  \futurelet\nextChar\getnumA}%
% end reding, after \egroup come \begintext from \aftergroup
\def\getnumOK:{\afternumber\egroup}% end of number
\def\getnumWrong{\afternumber\egroup%
  \ifxR\TypeOfVerse R\fi%
  \NumOfVerse% return the number
  \let\TypeOfVerse=0}
%
\def\setverse{\global\let\TypeOfVerse=V\xdef\NumOfVerse{\the\savenum}}
\def\setref{\global\let\TypeOfVerse=R\xdef\NumOfVerse{\the\savenum}}
%%%%%  
%
% 
%
\newwrite\logchords%
\immediate\openout\logchords=allchords.aux
\newbox\lasttext%
\newbox\lastchord%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% "text environment"
\def\begintext{%
  \ifvmode \noindent \MakeParBegin \fi%
  \setbox\lasttext=\hbox\bgroup\aftergroup\endtext}%
\def\endtext{%
  \ifvoid\lastchord \box\lasttext% test trivial case
  \else\typechord%
  \fi%
}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% typechord - put boxes \lastchord and \lasttext together
% ---------
% parametrs:
\def\fixchordspace{0.5em}  % min space between chords 
\def\pluschordspace{0.5em} % additional space, if we do prolongation of text
\def\chordraise{2.1ex}     % raise of the chord
%%%%%%%%%%%%%%%%%%%%%%%%%%%
% prolongation of the text inside of word
\def\chordinshypen{%
  \divide\dimen0 by 2%
  \ifdim\dimen0<0.3em\dimen0=0.3em\else\fi%
  \hskip\dimen0 plus 1em{-}\hskip\dimen0 plus 1em%
}  
%%%%%%%%%%%%%%%%%%%%%%%%%%
% prolongation of the text in space
\def\chordinsspace{%
  \unskip%
  \ifdim\dimen0>3em{%
    \advance\dimen0 by -1.5em%
    \hskip.75em\leaders\hbox{--}\hskip\dimen0 plus 1em\hskip.75em%
  }%
  \else{\hskip\dimen0 plus 1em}%
  \fi%
}
%%%%%%%%%%%%%%%%%%%%%%%%%%%
\def\typechord{%
  \dimen0=\wd\lastchord% d0:=wd(chord) + fixchordspace - wd(text)
  \advance\dimen0 by \fixchordspace%
  \dimen1=\dimen0%
  \advance\dimen0 by -\wd\lasttext%
  \wd\lastchord=0pt%
  \raise\chordraise\box\lastchord% insert chord with zero width
  \ifdim\dimen0<0pt{\unhbox\lasttext}% the best case 
   \else{% try streach the text
      \setbox0=\hbox to \dimen1{\unhbox\lasttext}%
      \ifnum\badness<250{\box0}% still good case
      \else{\unhbox0% fill the space or hypen a word      
         \advance\dimen0 by \pluschordspace%
         \ifdim\lastskip=0.0pt{\chordinshypen}%
         \else{\chordinsspace}%
         \fi%
      }\fi%
   }\fi%
}  
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% "chord environment" 
% 
% has a form:
% [A-H][bx]?\(m\|mi\|maj\|+\|-\|dim\|sus\)?
% \(([0-9]*[+-]?\(/[0-9]*[+-]?\)?)\)?\(/[A-H][bx]?\)
%
% with two extensions *([0-9])* == *[0-9]* and *(*)/* == *(*)*
% b is for flat, x for sharp - with this setting you can use
% national keyboards for typing without switching 
% there may not be any {,}, or control sequence
%
\def\beginchord{%
  \egroup% end text environment
  \setbox\lastchord=\hbox%
  \bgroup$% whole chord is in math mode ?? realy need this ??
  \catcode`\^^M=15\catcode`\(=12\catcode`\b=11\catcode`\"=12%
  \setformatA%
  \let\chordnext=\readchordbase%
  \readchord%
}%
\def\endchord#1{%
  \ifx)#1\else\errmessage{Wrong end of the chord}\fi%
  \immediate\write\logchords{\the\savechord}%
  $\egroup% end math chord box 
  \let\chordnext=\ENDOFCHORD%
  \begintext%
}  
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% chord parsing macros
% --------------------
% define some spec. tokens
{\catcode`\b=11\catcode`\"=12%
\global\let\sharpCh="%
\global\let\flatCh=b%
}
%
% readchord - reads whole chord and parse individual sections
\newtoks\savechord%
\def\readchord#1{%
  \expandafter\savechord\expandafter{\the\savechord#1}% save for export
  \let\mynext=\readchord% continue
  \chordnext{#1}%
  \message{\meaning\chordnext}%
  \ifx\chordnext\ENDOFCHORD% only after closin chord group -> after endgroup
    \let\mynext=\relax% .. so stop reading 
  \fi  
  \mynext%
}
%
% testtok - to test various tokens without many included "if"s
\def\testtok#1#2#3{%
  \ifx#1#2\ifx\chordnext\relax\let\chordnext=#3\fi%
  \fi%
}  
% 
% readtone - (for readchordbase & readchordbass)
\def\empty{}
\newtoks\tonechar\tonechar={\empty}%
\def\readtone#1{%
  \expandafter\ifx\the\tonechar\empty%
     \tonechar={#1}%
     \let\chordnext=\relax% continue with my caller (it must catch it)
  \else% continue with set succesor
    \ifx#1\sharpCh\typetone{\the\tonechar}{#1}\tonechar={\empty}%
    \else\ifx#1\flatCh\typetone{\the\tonechar}{#1}\tonechar={\empty}%
    \else%
       \typetone{\the\tonechar}{O}\tonechar={\empty}%
%       \message{\meaning\chordnext}%
       \chordnext{#1}% force succesor with same token
    \fi\fi%
  \fi%
}
%
% readchordbase - reads base of the chord
\def\readchordbase#1{%
  \setformatA%
  \let\chordnext=\readchordtype% set succesor
  \readtone{#1}%
  \testtok!!\readchordbase% test \relax from \readtone
}  
%
% readchordtype - such text as m,mi,maj,sus,+,-,dim
\def\readchordtype#1{%
  \let\chordnext=\relax%
  \testtok(#1{\breadchordexp\let\endexptok=)}% normal exp in ()
  \testtok/#1\breadchordbass%
  \testtok)#1{\relax\endchord{#1}}% force end
  \testtok+#1{\readchordtype\typebaseplus}%
  \testtok-#1{\readchordtype\typebaseminus}%
  % simple exp begin with digit and end with / 
  \testtok2#1{\relax\let\endexptok=/\breadchordexp{#1}} 
  \testtok4#1{\relax\let\endexptok=/\breadchordexp{#1}} 
  \testtok6#1{\relax\let\endexptok=/\breadchordexp{#1}} 
  \testtok7#1{\relax\let\endexptok=/\breadchordexp{#1}} 
  \testtok9#1{\relax\let\endexptok=/\breadchordexp{#1}} 
  % very rare cases
  \testtok1#1{\relax\let\endexptok=/\breadchordexp{#1}} 
  \testtok3#1{\relax\let\endexptok=/\breadchordexp{#1}} 
  \testtok5#1{\relax\let\endexptok=/\breadchordexp{#1}} 
  \testtok!!{\readchordtype#1}% normaly type all text
}  
%
% (b)readchordexp - additional harmonization
%
\def\breadchordexp#1{
  ^\bgroup% go up - only the first time
  \readchordexp{#1}%
}  
\def\readchordexp#1{%
  \setformatB%
  \let\chordnext=\relax%
  \testtok+#1{\readchordexp\typeexpplus}%
  \testtok-#1{\readchordexp\typeexpminus}%
  % egroup is special - first check regular end i.e. ) or /
  \testtok\endexptok#1{\relax\egroup\let\chordnext=\breadchordbass}% go down
  % if ) isn't regular end we have to end whole chord
  \testtok)#1{\relax\egroup\endchord{#1}}%
  \testtok!!{\readchordexp#1}% normal type
}
%
% read bass 
\def\breadchordbass#1{% only first time
  \let\chordnext=\relax
  \testtok/#1\breadchordbass%
  \testtok)#1{\relax\endchord{#1}}%
  \testtok!!{\relax% we have some non trivial material
    \CHslash\readchordbass{#1}%
  }
}  
\def\readchordbass#1{%
   \setformatC%
   \let\chordnext=\endchord% set succesor
   \readtone{#1}% ... so try 
   \testtok!!\readchordbass% test \relax from \readtone
}  
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%5
% Chord typing
%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% set default typing macros
\def\makedefaulttypeset#1(#2){%
  \ifx\X#1\let\next=\relax%
  \else%
    \expandafter\def\csname Chord#1O\endcsname{#2}%
    \expandafter\def\csname Chord#1b\endcsname{#2\CHflat}%
    \expandafter\def\csname Chord#1x\endcsname{#2\CHsharp}%
    \let\next=\makedefaulttypeset%
  \fi%
  \next%
}
%
% ... and then simple typing macro
\def\typetone#1#2{\csname Chord#1#2\endcsname}%
%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% turn on/off active numerals
\def\setactivenumerals{%
  \count255=`\0\advance\count255 by -1%
  \loop%
     \advance\count255 by 1%
     \catcode\count255=13%
     \count10=\count255\advance\count10 by -`\0%
     \bgroup\uccode`~=\count255%
     \uppercase{\egroup\edef~}{\noexpand\Beginexp\the\count10\egroup}
     \ifnum\count255<`\9%
  \repeat%
}
\def\noactivenumerals{%
  \count255=`\0\advance\count255 by -1%
  \loop%
     \advance\count255 by 1%
     \catcode\count255=12%
     \ifnum\count255<`\9%
  \repeat%
}  
%
%
%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% C O N F I G U R A T I O N
%
% tone names
\makedefaulttypeset%
C(C)D(D)E(E)F(F)G(G)A(A)B(B)\X(\X)%
%C(Do)D(Re)E(Mi)F(Fa)G(Sol)A(La)B(Si)\X(\X)%
%
% exceptions !!!!!!!!!!!!!!!!!!!!
\def\ChordAb{A\kern-.1\CHflat}
\def\ChordAx{A\kern-.1\CHsharp}
% Czech system
\def\ChordHO{H}
\def\ChordHb{B\CHflat}    % error correction
\def\ChordHx{H\CHsharp}
\def\ChordBO{B}          
\def\ChordBb{B}           % error correction
\def\ChordBx{H\CHsharp}   % error correction ???
%
% spec.chars
\def\CHflat{^\flat}%
\def\CHsharp{^\sharp}%
\def\CHslash{/}%
\def\typeexpplus{+}%
\def\typeexpminus{-}%
\def\typebaseplus{+}%
\def\typebaseminus{-}%
%
% set fonts
\def\setformatA{\fam=6} 
\def\setformatB{\fam=6}
\def\setformatC{\fam=0}
%
\def\MakeSongHeader#1#2#3#4#5{{
\noindent\bf #1 \hfill #5\par%
\noindent\hskip 3em\it #2\par}}
% every paragraph in the song environment is started by
% \noindent so the user can setup indentation of one's own
%  
\def\MyParBegin{%
  \ifx V\TypeOfVerse \hbox{\MakeVerse\hfil} to \parindent%
  \else\ifx R\TypeOfVerse \hbox{\MakeRef\hfil} to \parindent%
  \else\hskip\parindent%
  \fi\fi%
}%  
\def\MakeVerse{\NumOfVerse.}
\def\MakeRef{R\NumOfVerse:}



\tracingmacros=2
\tracingcommands=2
\tracingrestores=1
\hrule

%Testovaci text s akordy
%Kaz(Abm(7+)/C#)dykonecradku(Dm(7)/Bb)je ... 
%(D+)du(Am)le(B-)zity
%
%... i prazdny
%(Cm)(C+)(C-)(Cdim)(Cb)(C#)
%(Dm)(D+)(D-)(Ddim)(Db)(D#)
%(Em)(E+)(E-)(Edim)(Eb)(E#)
%(Fm)(F+)(F-)(Fdim)(Fb)(F#)
%(Gm)(G+)(G-)(Gdim)(Gb)(G#)
%(Am)(A+)(A-)(Adim)(Ab)(A#)
%(Hm)(H+)(H-)(Hdim)(Hb)(H#)
%(Bm)(B+)(B-)(Bdim)(Bb)(B#)
%

\inputsong{Amazonka.sng}

\bye



